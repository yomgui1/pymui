=> create a new CPointer instance with address = 0x1234

CPointer(0x1234) => CPointer instance

=> and for NULL address?

CPointer(0) and CPointer(None) return None.

=> Is CPointer() valid ?

-> Yes, give a None for CPointer.
-> For subclass, no rules. For example: RastPort() give a new allocated rastport.

=> create a new PyMuiObject instance (CPointer subtype):

PyMuiObject()
-> Don't give any arguments. No MUI object associated until _create() called with right arguments.

=> create a PyMuiObject from a NULL address:
-> Like CPointer

=> create a PyMuiObject instance from a existant C Object pointer.

PyMuiObject(0x1234) => instance
-> it's not a new instance. Just get the PyMuiObject from the given Object address, incref the py object and return it.

---------------------

Array and Python

For MUI (and C), an array is just a bunch of memory addressed by a pointer.
It's like a special structure, where we have n fields, all with the same type.

This type can be anything... A number as well as a complex structure, or another array.

The array can be created by the user, so handled by this one also (new/del).
In this case a user of this array (like a MUI class) shouldn't move the bunch somewhere else.
It can make a copy of it, but in this case the user know that. It's specified.
As well, an array can be created by someone else the user: this last shouldn't del
this array except if it stricly specified (rare case, because in general the user
don't know how to do that).
As an array is just a bunch of memory, this bunch could be WR or RO.
WR arrays are used to pass some data between a program and the user.
RO arrays are used to pass data in only one direction, data shouldn't be modified.

About references, as an array can contains anything, it can contain some data related
to some Python objects. So these data may only be valid during the life of this object,
or only during the creation of the array. If a program takes an array of this type,
this data should be valid until the program doesn't use it anymore.
So reference counter of these python objects should be increased to keep them alive.

But not all python types are in this case. A int or a bool are always valid, as it's
a basic C type also. The convertion of these kind of type is trivial.

Now, in the case of an array filled by and coming from the application, data inside
are generaly not a Python object, so a convert function should be used to transform
these data in Python objects first, then the Python array should implement the Sequence
protocol to give access to these objects.
And as an array of this type couldn't be destroyed without inform the user of that,
the Python array type can convert and give at demand array data.

Now, arrays should have a static size or data should be interpretable to know the end
of the array, like the special character \0 in a string (...an array of char).

So how to define a python array?

- it's a pointer on a memory buffer.
- contains items of a non-size-mutable type
- can act like a sequence object: if the number of items defined
at construction and not changeable.
- implement the iterator protocol: specialy if the number of items is not
know at construction, but the end of array is determinated by value of data.
- it uses a convert function to translate C data into Python object.

---------------------

I've just read sources of ctypes. I've seen that they uses metaclasses in C.
It was what I wanted to do at one time, but I choosed to use CPointer as a base type.
And now I'm pretty blocked to design CArray and handling basic C types like interger/float/...
So I'll do like ctypes. Thanks to its developpers for the idea.

I love metaclasses :-D

So this is my design:

- Metaclasses:

PointerType_Type: give it a CValue subclass as pointer type.
StructType_Type: 
ArrayType_Type

- Classes:

CValue_Type (base class, purpose is to give methods to transfert data between C and Python,
            subclasses use metaclasses also to customize these methods and add new features)
  Pointer_Type
  Struct_Type
  Array_Type

- Members:

CValue:
    * C fields:
      - size: number of bytes to contains the C value in memory.
      - items: [only for containers classes, like CArray] numbers of items.
      - data: an union of all C basic types, even void *. Usage depends on subclasses.
      - flags: general purpose to define what field it use or not.

    * Abstract C functions to be filled by meta:
      - from_c : convert a C value into python instance of the class.
      - to_c : convert a python instance of the class into its C value.
    
    * Python methods:
      - __new__(): proto subclass dependent.

- Usage samples:
* How to create a type Pointer on a short?
  -> PointerType('s') -> Pointer

* How to create a Pointer on a short, initialized to 45?
  -> Pointer(45, 's')

* How to create a Pointer of pointer on a short?
  -> Pointer(Pointer(45, 's'), 'p')

* So what does Pointer(Pointer(45, 's'))?
  -> A exception! Pointer type is a base for all pointer but can't create instance if no type is given.

* A NULL pointer ?
  -> It's None, so Pointer(0) or Pointer(None) returns None.
  -> Note: a NULL pointer doesn't have a type, so PointerType('s')(0) give None also.

* Make a type PointerPointerShort ?
  -> PointerType(PointerType('s'))

* A C function wants a pointer on an unsigned short. We ony have a Python int.
  -> In the python script, convert the int into a c_ushort instance object.
  ->
  -> The method will call the C function giving a pointer using ptr_obj.get_address()


---------------------

** Notification ideas **

C version:
  Notify(spyed object, attribute to spy, waited value,
         object notified, method called, method arguments...)

- Prototype forced, <waited value> is always a C LONG value (too bad for float, long long, double!).
- <waited value> has special value like MUIV_EveryTime, equals 0x49893131.
(=> that cause a serious pb if I'm waiting for this value only!)
- <method arguments> can be MUIV_TriggerValue or MUIV_NotTriggerValue.
(As MUIV_EveryTime, too bad if you want to use this value as a real number.)

In Python?:
 -> become a method of object, <spyed object> in first.
 -> remove the pb of special MUIV_EveryTime value (we always notify,
 the upper layer make the difference).

 -> So two way to Notify for the user:
    everytime: x.Bind(AttributeChangeEvent(attr), callable, args)
    conditionnal: x.Bind(AttributeChangeEvent(attr, value), callable, args)

    - Bind() first argument is always an AttributeChangeEvent (or subclass) instance object.
    (permit futur extensions.)
    - x.UnBind() is called with the same event object.
    - when callable is
