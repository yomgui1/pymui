***** Ma vie, mon oeuvre... *****

* "dur dur... très dur!"

Pour faire un 'wrapper' Python pour MUI, tout le problème est qu'il faut savoir quand un objet meurt (= OM_DISPOSE).
Car comme l'objet Python va garder une référence  sur cet objet MUI (ou BOOPSI comme on veut...), il faut donc être sur
que si on détruit ce dernier, l'objet MUI le soit aussi (ca c'est la partie simple: on appel MUI_DisposeObject () durant le dispose
de l'objet python), mais aussi indiquer à l'objet python que l'objet MUI est détruit si jamais la méthode OM_DISPOSE de ce dernier
est appelée (extérieurement, pas depuis le wrapper bien-sûr pour ne pas faire une boucle-infinie avec le premier cas).
Evidement c'est ce dernier cas où tous les problèmes surgissent...

Pourquoi? Il faut être certain d'être notifié (du côté python) de l'appel à la méthode OM_DISPOSE! En effet, les méthodes pour Python
associées vont forcement utiliser cet object MUI, aui doit alors être valide.

De quoi dispose t'on alors?

1) Ne cherchons pas du côté de la classe Notify. Le système de notification de MUI ne fonctionne que sur des changenents
de valeurs des attributs des objets... pas des méthodes.

2) BOOPSI? Pouvoir savoir si OM_DISPOSE est appelé à coups-sur serait de contrôler le code du dispatcher de l'objet MUI.

Comment faire cela? Ils y a plusieurs possibilitées:

    a) Faire une classe 'wrapper' dont la super-classe serait identique à l'objet BOOPSI où on aurait le contrôle du dispatcher,
    en particulier de notre méthode OM_DISPOSE et où on appelerait CoerceMethod() avec la classe d'origine de l'instance wrappée.

    => problèmes: vu que la classe d'origine s'attend à avoir ses données d'instance rattachés au pointeur associé il faut donc copier
    ces données juste après la création donc pendant OM_NEW. Ainsi la classe d'origine n'ira pas taper n'importe où en mémoire.
    C'est faisable, mais... quand on crée l'objet avec notre custom classe on passe les arguments comme si c'était la vraie classe, là c'est ok.
    Mais comment fait-on pour une instance déjà créer, ailleur que par ntore code Python? On ne peut-pas créer une instance de notre custom class
    pour contenir cette instance car pour faire cela notre custom classe doit avoir comme super la même classe que l'instance d'origine.
    Or on ne connait pas les paramètres qu'il faut employer avec cette super classe! Il est trés parfaitement possible d'avoir des paramètres
    obligatoires qu'on ne peut deviner. Ceci nous empêche alors d'utilisé des instances d'objets BOOPSI (= MUI) crées ailleur
    que par notre module Python. Trop restrictif... abandonnons cette solution. Et même si on on fait une impasse sur les instances externes
    d'autres problèmes sont à résoudre comme des classes qui gardent des pointeurs sur les instances (alors qu'on va justement créer une nouvelle
    instance qui wrappe la première...), ce que je soupconne fortement car d'après quelques tests mes instance de classe Window ne veulent pas
    êtres   reconnues par la classe Application (et donc rattachées...).

    b)  Disons qu'on garde alors notre instance qu'on veut embarquer dans une objet Python, on va donc s'attaquer juste au hook du dispatcher
    qui est sauvé dans la structure IClass assocée avec l'instance. Remplaçons donc les fonctions h_Entry et h_SubEntry de façon à faire executer
    notre propre dispatcher, qui lui-même appelera le dispatcher d'origine qu'on aura préalablement sauvé (d'ailleur rien que ce point est un problème).

    => problèmes: il faut savoir que l'adresse du hook est l'adresse de la structure IClass puisque la structure Hook y est embarquée au début.
    C'est pour cela que le prototype du dispatcher commence par struct IClass * et non pas par struct Hook * comme tout hook car en fait
    c'est la même chose ici. Le dispatcher étant tout simplement appelé par CallHook (ou CallHookA). On peut ce dire 'cool! Alors appelons
    dans notre dispatcher custom le dispatcher d'origine!'... Et bah non, car comme on vient de le dire, on n'appel pas la fonction directement
    mais on passe par CallHook, qui s'attend à avoir un pointeur sur un hook. Mais on ne peut pas passer une nouvelle structure hook
    remplie avec les fonctions d'origines, car le pointeur change donc les données qui suivent la structure ne sont plus celle de la structure IClass.
    Donc, soit juste avant d'appeler avec CallHook le "hook-IClass" on revient avec les fonctions d'origines et on remet notre dispatcher
    just après l'appel, et ainsi la classe d'origine n'y voit que du feu (mais cela rajoute du code qui ralentit le dispatcher), soit on appel comme
    un gros cochon la fonction h_Entry "à la main" (avec tout ce que cela implique pour MorphOS = setup des registres 68k,
    appel de la couche émulation, ...). Alors déjà c'est franchement plus très propre tout cela mais rajoutons qu'on est en train de modifier le code
    de la structure IClass, qui nous appartient pas du tout et donc on ne gère rien niveau vie (on retire comment notre disptacher si la classe
    doit  être détruite?). Et c'est pas tout car on touche à des classes étant quasiement à coups-sûr utilisées ailleur que par notre module.
    Résultat si notre module n'est pas 100% robuste on crash tous le système... et quand on quitte python on a intêret à faire le ménage proprement!
    Alors solution envisageable mais très peut fiable (et je n'ai même pas parlé comment enregistré les fonctions du hook d'orginine!).

    c) Patcher une fonction:
    - J'ai tenté de patcher DisposeObject() de l'intuition.library. Effectivement cette fonction est bien appelé fréquement pour détruire un object.
    Malheureusement cela n'est pas systèmatique, on peut-très bien appeler 'à la main' la méthode OM_DISPOSE et le meilleur (ou pire..) des exemples
    pour cela est la fonction MUI_DiposeObject() de la muimaster.library. Patcher cette dernière alors (aussi...)? Cela n'arrange en rien
    l'appel 'à la main'. Donc on oublis.

    d) Il me reste plus comme choix de patcher la rootclass... C'est pas très propre, mais au moins on patch uniquement qu'une seule classe.
    L'idée est donc de modifier (comme expliqué en 2)) le hook de la classe root pour appeler notre prope dispatcher, propre à avertir
    le pendant pythonesque de l'objet de la décision morbide de l'objet BOOPSI (donc MUI par l'occasion).
    Reste à savoir où sauver les anciennes valeurs du hook. Sachant de plus qu'il ne faut faire cela qu'une seule fois (on va pas cummuler
    les patches n'est-ce pas...) et vu que notre module peut-être initialisé plusieur fois (au moins une fois par tâche utilisant
    la bibliothèque Python), le plus simple est d'externaliser la procédure de patch dans un code à part, en attendant que le système
    d'initialisation des modules Python pour MorphOS implémente un appel unique (ce que je ne pense pas au passage).
    Maintenant qu'on est d'accord, sur la façon de connaìt§re à coup-sûr la mort d'un objet, il faut trouver un moyen de mettre en relation,
    l'objet MUI avec sont pendant Python.
    Côté Python pas de pb, c'est enregistrer par notre module dans la structure Data de l'objet Python.
    Côté BOOPSI maintenant... Sauf erreur de ma part, impossible de mettre un pointeur (celui de notre objet Python) quelque part dans l'instance
    de l'object :-( . J'ai vérifé 20x, rien!
    Unique façon restante, utiliser une table de correspondance BOOPSI -> Python. Pour accélérer la recherche dans cette table
    on pourra utiliser une indexation par hachage du pointeur de l'objet BOOPSI. Reste à dimensionner tout cela pour que cela reste
    efficace en terme d'accés.
    Dernier point pour la route: comme les modules sont liés (en terme de données) au process exécutant, la table de correspondance
    l'est donc aussi!
    Donc si un process A demande de tuer un objet x et qu'un process B utilisant le module Python posséde un objet Python y
    lié avec cet objet x, comment allons nous retrouver cette table et comment avertir le process B?
    Il faut donc lier cette table avec le code de notre dispatcher, table qui contiendra des objets Python de différentes instances
    de notre module. Les objets python seront déliés de la partie BOOPSI dans le dispatcher. L'accés au data du côté Python sera
    protégée par l'utilisation d'un sémaphore pour gérer l'aspect multi-processes. Comme un objet BOOPSI peut-être lié à de multiples
    objets Python, on utilisera une liste pour chaque objet BOOPSI, donnant ces objets Python liés.

- Ré-évalutation:
    Due à la complexité du code généré par une version où chaque objet BOOPSI peut-être associé avec plusieurs objets Python
    (cas de plusieurs appli utilisant le module, se partagant un objets BOOPSI), une simplification s'impose...

    Définition des régles:
        REG-01: associativité 1-1 entre BOOPSI et Python.
        REG-02: code non re-entrant (même pour la destruction, donc attention!)
        REG-03: pas de communications d'objets entre tâches.
        REG-04: seulement la tâche ayant associée l'object python et l'objet boopsi peut les dissocier.

- News du 01/11/07:
    L'implémentation du 2-d aurait du fonctionner...  en théorie. Mais la pratique ne l'est pas du tout! Après une discussion IRC
    avec Stuntzi il s'avère que MUI ne suit pas les règles de BOOPSI, encore moins les appels indirects aux dispatchers des classes internes.
    Ceci expliquant l'impossibilité de patcher les dispatchers des classes MUI => il ne sont pas appeler par le pointeur dans la structure IClass.
    Devant ce fait il ne reste donc plus qu'une seule façon d'opérer: sous-classer toute classe utilisée. Cette dernière implique
    certaines restrictions que je ne souhaitait pas (cela explique que j'en avais pas encore parlé):
        - Le module ne pourra qu'opèrer sur des objets créé par lui-même. Aucun objet de l'extérieur (=déjà créé).
        - Impossible de passer un objet X du process l'ayant créé vers un autre. MUIM_Application_PushMethod ne peut-être utilisé.
        (Ceci n'est pas encore certain... il faudra y réfléchir après l'implémentation de la phase 1).
        - Pas d'objets 'builtins' => on ne peut pas les sous-classer!

- Autre soucis: quitter Python doit de-allouer tout objets, même ceux qui ont encore des ref > 0. Le pb évident c'est qu'on ne peut pas le faire
dans n'importe quel ordre: si on prend un objet A ayant une référence sur un objet B, qu'on détruit l'objet B puis le A, si le A doit opérérer
sur l'objet B on est dans le baba! A va accéder à un objet mort, donc de la mémoire aléatoire => crash.
C'est ce qui arrive en ce moment (20080107) quand je quitte Python: l'objet Application n'est pas détruit le premier (aléas l'algorythme interne
de Python quand il détruit tout), mais par exemple un objet Text inclus dans une fenêtre, incluse dans l'appli...

Solution:
=> augmenter le compteur de réf de l'objet Python ou un autre privé quand l'objet MUI est "parenté" dans un autre objet MUI, à
l'instar de Python.
=> Je pense que cela sera un compteur privé (histoire de pas tout mélanger).

3) (News du 01/09/09) Après qq années à réfléchir (...) il y a beaucoup plus simple en faite...

- Pour le problème de savoir quand on objet MUI est détruit pour ne plus être utilisé du côté python:
=> ON S'EN TAPE! (La solution ultime à tous les problèmes du monde :-D)
On faite c'est très simple, la règle est la suivante: un objet MUI ne doit pas être 'disposé' par personne, sauf:
  - Par l'application elle-même, quand l'objet y est lié, directement ou non, car l'application est 'disposée' par notre module.
  - Par le type Python l'encapsulant, mais seulement si l'objet MUI n'est pas lié (MUA_Parent == NULL),
    exception faite de l'application elle-même évidement (car MUIA_Parent(app) == app).
100 ligne de blabla résolus...

- Reste le problème des références sur des choses données en paramétres à des fonctions BOOPSI/MUI qui les enregistes.
=> pas solutionnable localement, c'est au programmeur d'en tenire compte!
=> Notes pour la documentation utilisateur:
   Expliquer le pb de garder des références des valeurs données.

**********************************************************************************************************************************************************

L'eau à coulée sous les ponts! PyMUI est arrivé à une certaine maturité, il utilise le module ctypes pour effectuer le passage entre le monde
Python et MUI pour les "valeurs".
Mais après quelques développements "lourds" (comme Gribouillis) je m'appercois que certaines classes sont dures à utiliser (ex. implémenter la méthode
MUIM_List_Display de la classe List, trop de convertions compliquées et en plus une gestion hazardeuse des références entre python et boopsi).

Il est temps de remettre les choses à plat:

BOOPSI: MUI étant totalement basé dessus, concentrons nous d'abord sur celui-ci.
-> BOOPSI c'est de l'objet dynamique: les objets sont des instances de classes.
Une classe implémente (le code) les methodes, manipulant de façon générique des données données dynamiquements (ex. OM_SET/OM_GET) ainsi
que celles stockées dans le block de données de l'instance (l'objet).
L'instance ne représente donc qu'une allocation unique de ce block de donnée, manipulé par les méthodes de la classes.

-> Les instances ne peuvent exister que si la classes dont elles proviennent existe.
=> Sous BOOPSI, une classe ne doit pas être détruite tant que des objets l'utilisant existent.
=> Mais BOOPSI ne protège en rien l'utilisateur cette régle! Attention aux crashes...

-> Il y a 2 fonctions pour créer des objets sous BOOPSI: NewObjetA() et NewObjet().
=> MUI rajoute aussi MUI_NewObjectA(), MUI_NewObject() et MUI_MakeObject().
=> soit un total de 5 fonctions possibles.

-> Il y a 1 fonction BOOPSI pour détruire un objet BOOPSI: DisposeObject().
=> MUI rajoutant lui: MUI_DiposeObject().

-> Aucun moyen de savoir quand un objet est créé ou détruit (sauf si on est l'originateur de l'action).
=> Ni sous BOOPSI, ni sous MUI.
=> Pire, rien n'est assuré qu'en interne des bibliothèques intuition ou muimaster, le respect stricte aux
appels précédents (Note: vérifié! MUI détruit des objets sans passer par (MUI_)DisposeObject(), ni même par
le dispatcher!!!).

-> Il n'y a pas de méchanisme de référencement comme sous Python, l'implémenteur de la classe doit le faire de lui-même.
=> La destruction d'un objet devient dépendant de la classe voir d'autres classes.
=> Par exemple sous MUI, où l'application détruit ses fenêtres attachées, elles même leur 'RootObject' et ainsi de suite.

-> Autant il est possible (mais pas facile, demande de créer des MCCs à la volées) de lier un objet BOOPSI à un objet
Python si le module python est le créateur de l'objet BOOPSI.
Autant il est impossible de le faire pour un objet créé hors du module et donc impossible pour les objets pré-définis,
créés avec MUI_MakeObject().

-> L'appartenance d'un objet à une classe donnée est possible mais non directe car aucune API dans BOOPSI
n'a été prévue à cet effet.

On en deduit donc:
1) qu'il est difficile voir impossible d'avoir une méthode automatique et générique pour gérer la création/destruction
d'un objet BOOSI au travers d'un objet Python.

**** Solution envisageable ****

=> il faut que l'utilisateur du module devienne responsable de cette gestion.
=> L'objet Python devient un simple proxy vers un objet BOOPSI, sans à avoir l'assurance que cet objet:
 a) soit valide (pas détruit).
 b) qu'il implémente bien la classe attendue (bien que ce dernier point peut-être résolus).
=> Donc à un objet BOOPSI correspond plusieurs objets Python possibles. A l'inverse, à un objet Python
ne peut correspondre qu'un objet BOOPSI.

2) Il est difficile ou impossible de lié de façon bidirectionnelle un objet Python à un objet BOOPSI.
=> comment alors gérer les notifications de MUI? La version actuelle utilise un Hook fixe appelé
avec un objet MUI, ce dernier devant être lié avec un objet Python, sinon quoi il n'est pas
possible de savoir quels sont les callbacks Python associées.
=> Liaison uni-directionnelle (Python -> BOOPSI) uniquement. Si un objet doit être reconvertis
vers un objet Python, un nouvel objet est recréé.
=> la solution d'utiliser un dictionnaire pour la résolution inverse ne peut-être utilisée à cause
du point 1), vu qu'on ne peut savoir précisément quand un objet BOOPSI est détruit (et donc la mémoire
réutilisée, voir pour un autre objet BOOPSI).
=> pourtant il faut une solution car sinon il est impossible d'affecté des données à un objet Python
sous peine de pouvoir les retrouver dans un Hook comme celui de la notification MUI.

**** Solution envisageable ****

=> Il y a 2 cas de figures:
   a) soit l'objet BOOPSI est créé depuis le module lui-même: on peut alors utiliser
une table associant un objet Python pour un objet BOOPSI donné.
   - L'objet Python est marqué comme "possédant" l'objet BOOPSI.
   - Si il advient que cette objet est lié avec un autre objet BOOPSI pouvant le détruire,
   l'objet Python pert alors ce marquage, mais cette action est manuelle et déclenchée par l'utilisateur à l'appel
   à une API donnée du module.
   -> Vu qu'il est utile de garder l'entrée, la valeur de la table sera non pas l'objet Python lui-même mais
   un weakref de ce dernier. Reste à l'utilisateur de sauver quelque part l'objet Python pour qu'il reste
   en vie suffisement longtemp au besoin.

   b) soit l'objet BOOPSI est d'origine inconnue: un nouvel objet Python lui est associé.
   Reste à l'utilisateur de pouvoir associé une classe Python particulière: prévoir une API pour.
   Evidement l'objet Python n'est pas marqué comme propiétaire.

=> Dans tous les cas on pourra ajouter cette association dans la table d'associativité:
elle devra être temporaire et gérée par l'utilisateur.
En cas de conflit (oublis d'enlever une entrée temporaire par exemple) une exception devra être provoquée.

=> l'utilisation d'une table inverse impose une restriction à la régle d'associativité décrite en 1):
si l'objet BOOPSI est dans la table, alors il ne peut y être associé qu'un seul objet Python, celui de la table.

**** Résultion du cas des notifiations MUI ****

=> puisque l'appel au hook ne peut être provoqué que si le module à lui-même appliqué cette notification avec un appel
à la méthode MUIM_Notify, on contrôle donc les arguments donnés: il suffit donc d'avoir un argument suplémentaire,
mais obligatoire, qui sera l'objet python correspondant.
=> la référence ne sera par contre pas incrémenté: malheureusement enléver une notification particulière
est compliquée voir impossible avec MUI. On pourra alors utiliser une structure allouée pour l'occasion,
qui contient la référence vers l'objet Python, cette structure sera donnée en argument. La référence
à la structure est gardée dans l'objet python, qui effacera sa propre référence dans la structure à l'appel
de la méthode de destruction de l'objet Python.
La structure ne sera jamais déallouée sauf lors de la destruction du module lui-même ou si appel à une API
de destruction (DisposeObject(), ...) si l'objet Python est propriétaire.

4) Multithreading

=> la table d'associativité et les structures pour les notifications devront être accéssibles pour les threads.

5) pb de la complexité d'implémentations des méthodes comme MUIM_List_Display avec des arguments aux types très variables.
=> à revoir.

**********************************************************************************************************************************************************

Comme d'hab.. j'ai tout ré-écris pour la v0.4!

J'ai voulus trop 'gérer' les problèmes de destructions des objects, résultant un code trop complexe.
Bien que c'est une ré-écriture (surtout du code C et des types), l'API vu de l'utilisateur reprend beaucoup de la v0.3.

Quoi de neuf?

1) Les conteneurs Python (PyBOOPSIObject et PyMUIObject) posséde un flag 'OWNER' si l'objet BOOPSI
affecté a été créé par la méthode _create().

On considère donc que ce flag permet de savoir si un objet n'est lié ** d'aucunes façons ** par
un autre objet BOOPSI (dans ce cas cet objet sera responsable de détruire l'objet BOOPSI référé).

Ce flag est perdu dans les cas suivant:
- L'appel à la méthode '_loosed' du conteneur.
- L'utilisation de la méthode '_addchild' d'un autre conteneur, pour créer une lisaison parent-enfant.

Reste aux classes de pymui et aux utilisateurs d'appeler correctement ces fonctions pour indiquer
à pymui si un objet doit ou non être détruit par lui.

2) Les références des objet BOOPSI (ou MUI), créés par le module, sont gardés dans une liste comme avant.
Lors du cleanup du module les objets de cette liste seront simplement détruits, à l'exception
des objets MUI: une vérification est faite pour voir si il ne sont pas liés à un objet parent ou à une application.
Les objets applications sont détruit en dernier (par définition, les applications n'ont pas de parent).

3) En plus du flag OWNER mis, l'objet conteneur est gardé dans un dictionnaire liant un 'weakref'
de cet objet (valeur) à l'adresse de l'objet BOOPSI (clé).

L'entrée est enlévée si il y a perte du flag OWNER.

Ce dictionnaire sera utile pour les Hooks (gestions méthode MUIM_CallHook et notifications).

3) La liaison parent-enfant n'est plus sauvé en interne, vu que les noeuds objets ne reste que si
l'objet n'est pas lié.

4) Le flags OWNER n'est jamais redonné une fois perdu!
Cela implique qu'à la suite de l'appel à la méthode '_remchild', l'objet BOOPSI peut se retrouvé
perdu et non détruit à jamais si on n'appel pas '_addchild' ou '_dispose' sur le conteneur rapidement.
Cela arrivera aussi si une exception intervient avant ces appels!
=> Une solution pourra être trouvé par la suite... mais cela va forcement rendre plus complexe le code.

5) Donc un objet BOOPSI ne sera disposé par le module que:

- par l'appel explicite à la méthode '_dispose' (non conditionnel, attention donc !)
- pendant la destruction du conteneur, si et seulement si le flag OWNER existe.
- pendant le cleanup du module si l'objet est toujours dans la liste des objets non liés.
et si l'objet est réellement non lié, pour les objets MUI uniquement.

6) Les références des conteneurs ne sont toujours pas changées lors des utilisations dans
les _set, _create et _do.

7) Le système de 'keep' a changer:
- soit l'utilisateur s'en occupte.
- les classes définissant des attributs ayant besoins de garder l'objet source lors d'une affectation
doivent l'indiquer dans la déclaration de l'attribut par l'appel à MAttribute().

Mais les types C (PyMUIObject) n'interviennent plus dans le processus.

8) Par design il ne doit être possible de créer un conteneur sans le flag OWNER, si
un conteneur ayant ce flag pour le même objet BOOPSI existe.

=======

Tout ceci à des impactes positives, par exemple l'ajout d'un 'RootObject' à une fenêtre
n'implique plus de garder une référence au conteneur comme avant. '_loose()' est automatiquement
appelé, le conteneur pert donc l'objet, il peut donc être détruit tranquillement ensuite.
=> plus de mémoire, moins de perte inutile.
=> c'est en plus le comportement 'logique' auquel on s'attend.

=======

MCC redesign:

PyMUI 0.3 pré-calcule une liste des méthodes python à appelées pour chaque méthode MUI
surchargée par la classe Python.
Cette liste est créée et liée pour chaque instance de la classe, ce qui est inutile!
Vu que ces méthode sont reliées à la classe et non pas à l'instance...

Un meilleur design serait de calculer cette liste qu'une seule fois.
Cela peut toujours ce faire pendant _create() car il n'y en a pas le besoin avant.

Ensuite, vu qu'un objet BOOPSI peut être relié à plusieur objets Python, il faut un moyen
de pouvoir récupérer cette liste, quelque soit l'objet Python.

Vu que la liste est liée à la classe, le champ IClass->cl_UserData sera utilisée pour cela.
La classe étant donnée à l'appel du dispatcher. 

Mais ce n'est pas fini: l'appel à une méthode d'un objet BOOPSI s'applique sur celui-ci,
donc l'appel à une méthode Python s'applique sur un objet PyBOOPSIObject ou PyMUIObject.
Par design, une méthode MCC peut-étre appelée par différentes tâches... donc
le code doit-être ré-entrant: cela ne facilite en rien l'obtention d'un objet Python particulier.
Si un code multitâches utilise PyMUI, il peut très bien appeler une méthode MCC depuis un objet
Python donné, et dans le même temps le faire depuis un autre objet Python aussi, par 2 tâches
différentes donc. Evidement les 2 objets Python réfèrent le même objet BOOPSI!
Quand le code du dispatcher étant appelé avec les mêmes paramêtres, impossible de savoir
ainsi quel objet Python il faut utiliser!

CORRECTION du dernier paragraphe:
-> le dispatcher n'est pas ré-entrant par défaut! C'est pour cela qu'il existe la méthode
MUIM_Application_PushMethod!

Par contre cela ne change pas le principe où on s'attend à avoir le même objet Python dans
la méthode surchargée que celui qui a appelé cette méthode.

Mais cet objet n'est connu que si le module lui-même invoque le DoMethod, car il peut passer
alors en paramêtre ce dernier. Sauf que MUI lui-même appel aussi les méthodes, sans cet objet
donc.

Il n'y a donc pas de moyen d'avoir un objet Python précis (sauf si un 'OWNER' existe, par la DB),
pendant l'appel à une méthode d'une MCC: les méthodes Python seraient donc des méthodes de classes!
=> aucunes garanties pour l'utilisateur de retrouver un objet Python particulier à partir
de l'objet BOOPSI donnée à l'appel de la méthode.

Ce n'est pas acceptable... de toute façon une méthode BOOPSI n'est pas déclenchée sans raisons.
Donc reprenons:

- si un objet Python ayant une classe _MCC_, déclenche l'appel à une méthode de l'objet BOOPSI qu'il référe,
c'est cet objet Python qui doit être utilisé dans PyObject_CallMethod().
-> on pourrait retenir dans une variable globale cet objet: sauf que cette solution n'est pas ré-entrante,
la variable serait toujours la même quelque soit le thread.
-> de plus pendant cet appel, une autres méthode BOOPSI sur un autre objet BOOPSI peut aussi être invoquée.

C'est le gros problème de la liaison multiple Python -> BOOPSI qui est de type N-1.

J'ai la solution!
=> garder le principe de liaison faible, mais du type 1-1 et plus N-1.
=> résultat à tout instant donné, il ne peut y avoir qu'un seul objet Python lié à un objet BOOPSI.
Mais attention: grandes précautions de l'utilisateurs, car cet objet peut changer dans le temps!
Cela donnera parfois des résultats étranges, mais pas moyen de faire autrement.

Donc la DB objet sera utilisée pour cela, auf que maintenant elle contient tous les conteneurs,
pas seulement ceux qui sont 'OWNER'.

Par contre ATTENTION: comme il impossible de savoir réellement quand un objet BOOPSI est détruit,
il est donc (presque) impossible d'enlever une entrée de cette DB.
Cette impossibilitée risque de faire croître la mêmoire.

Le 'presque' provient de deux cas uniques:
a) du fait qu'un objet utilisant une MCC pourra alors être enlévé puisqu'on contrôle les méthodes (OM_DISPOSE).
b) si l'objet Python est OWNER, alors on contrôle l'appel aux API pour la destruction.

Mais je pense à une solution: vu qu'on utilise un weakref comme valeur,
si plus aucun objet Python ne référence notre objet BOOPSI alors on détruit l'entrée.
A l'utilisateur de se débrouiller pour garder en vie son objet.

=======

Bon globalement le dernier design (cf au dessus) marche bien.
Mais j'ai encore des soucis (code pas beau, complexité d'écriture, ...) avec l'utilisation de MCC comme NList & Co.
Ou bien faire passer des buffers comme pour Rawimage.

Vu que les paramêtres aux méthodes/attributs sont toujours des LONG ou ULONG, c'est pas marrant de gérer au cas par cas
ces derniers: un attribut peut être un pointeur ou n valeurs partiulière... qui ne faut dés alors surtout pas utiliser
comme pointeur sino crash!

J'aimerai automatiser tout cela pour que l'écriture des classes soit plus aisées.. mais pas simple!

Genre: actuellement faire un 'get' d'un attribut retourne un objet de type PyMUICType.
Cela laisse le choix à l'utilisateur de pouvoir l'utiliser soit comme un entier (en le convertissant en long avec long(x)),
soit comme un objet plus complexe (avec la méthode .value ou autre, tout dépend de la classe).

Le problème avec cela c'est que l'écriture devient moins intuitive: on s'attend plus d'avoir un objet de type PyMUIObject
quand on exécute "obj.ApplicationObject", plus que de devoir faire "obj.ApplicationObject.value".
Surtout que le terme 'value' (qui vient ici de ctypes) prète à confusion: on pourrait croire que c'est la valeur entière!

Si je regarde 'chez les autres' ils implémentent tous leur méthodes/attributs en C ou C++. Pas moi.
Il va falloir que je trouve un autre moyen plus subtile pour indiquer comment interpéter une valeur entière C de MUI
vers un objet Python.

